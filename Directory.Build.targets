<?xml version="1.0" encoding="utf-8"?>
<Project>

  <!-- Custom Build Targets -->

  <!-- Build Performance Optimization -->
  <PropertyGroup>
    <RestoreUseStaticGraphEvaluation>true</RestoreUseStaticGraphEvaluation>
    <MSBuildEnableWorkloadResolver>false</MSBuildEnableWorkloadResolver>
  </PropertyGroup>

  <!-- Define BuildingBlocks project reference paths -->
  <PropertyGroup>
    <DomainProject>$(MSBuildThisFileDirectory)BuildingBlocks.Domain\BuildingBlocks.Domain.csproj</DomainProject>
    <ApplicationProject>$(MSBuildThisFileDirectory)BuildingBlocks.Application\BuildingBlocks.Application.csproj</ApplicationProject>
    <InfrastructureProject>$(MSBuildThisFileDirectory)BuildingBlocks.Infrastructure\BuildingBlocks.Infrastructure.csproj</InfrastructureProject>
    <APIProject>$(MSBuildThisFileDirectory)BuildingBlocks.API\BuildingBlocks.API.csproj</APIProject>
  </PropertyGroup>

  <!-- BuildingBlocks Package Metadata Configuration -->
  <PropertyGroup Condition="$(MSBuildProjectFullPath.Contains('BuildingBlocks')) and $(MSBuildProjectName.EndsWith('API'))">
    <PackageId>BuildingBlocks.API</PackageId>
    <Description>API layer building blocks for .NET applications following Clean Architecture principles</Description>
    <PackageTags>api;web;aspnetcore;clean-architecture;building-blocks</PackageTags>
  </PropertyGroup>

  <PropertyGroup Condition="$(MSBuildProjectFullPath.Contains('BuildingBlocks')) and $(MSBuildProjectName.EndsWith('Application'))">
    <PackageId>BuildingBlocks.Application</PackageId>
    <Description>Application layer building blocks for .NET applications following Clean Architecture principles</Description>
    <PackageTags>application;cqrs;mediator;clean-architecture;building-blocks</PackageTags>
  </PropertyGroup>

  <PropertyGroup Condition="$(MSBuildProjectFullPath.Contains('BuildingBlocks')) and $(MSBuildProjectName.EndsWith('Domain'))">
    <PackageId>BuildingBlocks.Domain</PackageId>
    <Description>Domain layer building blocks for .NET applications following Clean Architecture principles</Description>
    <PackageTags>domain;ddd;entities;value-objects;clean-architecture;building-blocks</PackageTags>
  </PropertyGroup>

  <PropertyGroup Condition="$(MSBuildProjectFullPath.Contains('BuildingBlocks')) and $(MSBuildProjectName.EndsWith('Infrastructure'))">
    <PackageId>BuildingBlocks.Infrastructure</PackageId>
    <Description>Infrastructure layer building blocks for .NET applications following Clean Architecture principles</Description>
    <PackageTags>infrastructure;repository;data-access;clean-architecture;building-blocks</PackageTags>
  </PropertyGroup>

  <!-- Clean Architecture Project Dependencies -->
  <Target Name="AddCleanArchitectureReferences" BeforeTargets="CollectPackageReferences">

    <!-- BuildingBlocks Domain layer - no dependencies on other layers -->
    <ItemGroup Condition="$(MSBuildProjectFullPath.Contains('BuildingBlocks')) and $(MSBuildProjectName.EndsWith('Domain'))">
      <!-- Domain has no project dependencies -->
    </ItemGroup>
    
    <!-- BuildingBlocks Application layer - depends on Domain -->
    <ItemGroup Condition="$(MSBuildProjectFullPath.Contains('BuildingBlocks')) and $(MSBuildProjectName.EndsWith('Application'))">
      <ProjectReference Include="$(DomainProject)" Condition="Exists('$(DomainProject)')" />
    </ItemGroup>

    <!-- BuildingBlocks Infrastructure layer - depends on Application only (gets Domain through Application) -->
    <ItemGroup Condition="$(MSBuildProjectFullPath.Contains('BuildingBlocks')) and $(MSBuildProjectName.EndsWith('Infrastructure'))">
      <ProjectReference Include="$(ApplicationProject)" Condition="Exists('$(ApplicationProject)')" />
    </ItemGroup>

    <!-- BuildingBlocks API layer - depends on Infrastructure only (gets Domain and Application through Infrastructure) -->
    <ItemGroup Condition="$(MSBuildProjectFullPath.Contains('BuildingBlocks')) and $(MSBuildProjectName.EndsWith('API'))">
      <ProjectReference Include="$(InfrastructureProject)" Condition="Exists('$(InfrastructureProject)')" />
    </ItemGroup>

    <!-- Service Projects Dependencies -->
    <!-- Service API projects reference BuildingBlocks.API and their own Infrastructure -->
    <ItemGroup Condition="$(MSBuildProjectFullPath.Contains('Services')) and $(MSBuildProjectName.EndsWith('API'))">
      <ProjectReference Include="$(APIProject)" Condition="Exists('$(APIProject)')" />
      <ProjectReference Include="..\Infrastructure\*.csproj" />
    </ItemGroup>

    <!-- Service Application projects reference BuildingBlocks.Application and their own Domain -->
    <ItemGroup Condition="$(MSBuildProjectFullPath.Contains('Services')) and $(MSBuildProjectName.EndsWith('Application'))">
      <ProjectReference Include="$(ApplicationProject)" Condition="Exists('$(ApplicationProject)')" />
      <ProjectReference Include="..\Domain\*.csproj" />
    </ItemGroup>

    <!-- Service Domain projects reference BuildingBlocks.Domain -->
    <ItemGroup Condition="$(MSBuildProjectFullPath.Contains('Services')) and $(MSBuildProjectName.EndsWith('Domain'))">
      <ProjectReference Include="$(DomainProject)" Condition="Exists('$(DomainProject)')" />
    </ItemGroup>

    <!-- Service Infrastructure projects reference BuildingBlocks.Infrastructure and their own Application -->
    <ItemGroup Condition="$(MSBuildProjectFullPath.Contains('Services')) and $(MSBuildProjectName.EndsWith('Infrastructure'))">
      <ProjectReference Include="$(InfrastructureProject)" Condition="Exists('$(InfrastructureProject)')" />
      <ProjectReference Include="..\Application\*.csproj" />
    </ItemGroup>

  </Target>

  <!-- Framework References -->
  <ItemGroup Condition="'$(MSBuildProjectName)' == 'BuildingBlocks.Infrastructure' OR '$(MSBuildProjectName)' == 'BuildingBlocks.API'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <!-- Clean artifacts directory before build -->
  <Target Name="CleanArtifacts" BeforeTargets="BeforeBuild">
    <ItemGroup>
      <ArtifactsToDelete Include="$(MSBuildThisFileDirectory)artifacts\**\*" />
    </ItemGroup>
    <Delete Files="@(ArtifactsToDelete)" ContinueOnError="true" />
    <RemoveDir Directories="$(MSBuildThisFileDirectory)artifacts" ContinueOnError="true" />
  </Target>

  <!-- Create artifacts directory structure -->
  <Target Name="CreateArtifactsDirectories" BeforeTargets="BeforeBuild">
    <MakeDir Directories="$(OutputPath)" Condition="!Exists('$(OutputPath)')" />
    <MakeDir Directories="$(BaseIntermediateOutputPath)" Condition="!Exists('$(BaseIntermediateOutputPath)')" />
    <MakeDir Directories="$(PackageOutputPath)" Condition="!Exists('$(PackageOutputPath)')" />
    <MakeDir Directories="$(MSBuildThisFileDirectory)artifacts\logs\" />
    <MakeDir Directories="$(MSBuildThisFileDirectory)artifacts\reports\" />
  </Target>

  <!-- Enhanced Git Information with CI/CD Support -->
  <Target Name="GetGitInfo">
    <PropertyGroup>
      <GitCommitId>unknown</GitCommitId>
      <GitBranch>unknown</GitBranch>
      <GitCommitMessage>unknown</GitCommitMessage>
      <GitTag>unknown</GitTag>
      <BuildNumber Condition="'$(BUILD_BUILDNUMBER)' != ''">$(BUILD_BUILDNUMBER)</BuildNumber>
      <BuildNumber Condition="'$(GITHUB_RUN_NUMBER)' != ''">$(GITHUB_RUN_NUMBER)</BuildNumber>
      <BuildNumber Condition="'$(BuildNumber)' == ''">local</BuildNumber>
    </PropertyGroup>
    
    <!-- Get Git Information -->
    <Exec Command="git rev-parse HEAD" 
          ConsoleToMSBuild="true" 
          ContinueOnError="true"
          Condition="Exists('$(MSBuildThisFileDirectory).git')">
      <Output TaskParameter="ConsoleOutput" PropertyName="GitCommitId" />
    </Exec>
    
    <Exec Command="git rev-parse --abbrev-ref HEAD" 
          ConsoleToMSBuild="true" 
          ContinueOnError="true"
          Condition="Exists('$(MSBuildThisFileDirectory).git')">
      <Output TaskParameter="ConsoleOutput" PropertyName="GitBranch" />
    </Exec>

    <Exec Command="git log -1 --pretty=format:%%s" 
          ConsoleToMSBuild="true" 
          ContinueOnError="true"
          Condition="Exists('$(MSBuildThisFileDirectory).git')">
      <Output TaskParameter="ConsoleOutput" PropertyName="GitCommitMessage" />
    </Exec>

    <Exec Command="git describe --tags --exact-match" 
          ConsoleToMSBuild="true" 
          ContinueOnError="true"
          Condition="Exists('$(MSBuildThisFileDirectory).git')">
      <Output TaskParameter="ConsoleOutput" PropertyName="GitTag" />
    </Exec>

    <!-- Truncate commit ID for display -->
    <PropertyGroup>
      <GitCommitIdShort Condition="'$(GitCommitId)' != 'unknown'">$(GitCommitId.Substring(0, 8))</GitCommitIdShort>
      <GitCommitIdShort Condition="'$(GitCommitId)' == 'unknown'">unknown</GitCommitIdShort>
    </PropertyGroup>
  </Target>

  <!-- Enhanced Version Information Generation -->
  <Target Name="GenerateVersionInfo" BeforeTargets="BeforeBuild" DependsOnTargets="GetGitInfo">
    <PropertyGroup>
      <VersionInfoFile>$(BaseIntermediateOutputPath)VersionInfo.cs</VersionInfoFile>
      <VersionInfoContent>
// <auto-generated />
using System.Reflection;

[assembly: AssemblyMetadata("BuildDate", "$(BuildDate)")]
[assembly: AssemblyMetadata("BuildMachine", "$(COMPUTERNAME)")]
[assembly: AssemblyMetadata("BuildUser", "$(USERNAME)")]
[assembly: AssemblyMetadata("BuildNumber", "$(BuildNumber)")]
[assembly: AssemblyMetadata("GitCommit", "$(GitCommitId)")]
[assembly: AssemblyMetadata("GitCommitShort", "$(GitCommitIdShort)")]
[assembly: AssemblyMetadata("GitBranch", "$(GitBranch)")]
[assembly: AssemblyMetadata("GitCommitMessage", "$(GitCommitMessage)")]
[assembly: AssemblyMetadata("GitTag", "$(GitTag)")]
[assembly: AssemblyMetadata("Configuration", "$(Configuration)")]
[assembly: AssemblyMetadata("TargetFramework", "$(TargetFramework)")]
      </VersionInfoContent>
    </PropertyGroup>
    
    <MakeDir Directories="$(BaseIntermediateOutputPath)" />
    <WriteLinesToFile File="$(VersionInfoFile)" Lines="$(VersionInfoContent)" Overwrite="true" />
    
    <ItemGroup>
      <Compile Include="$(VersionInfoFile)" />
    </ItemGroup>
  </Target>

  <!-- Build Information Logging -->
  <Target Name="LogBuildInfo" BeforeTargets="BeforeBuild" DependsOnTargets="GetGitInfo">
    <Message Text="==================== BUILD INFORMATION ====================" Importance="high" />
    <Message Text="Project: $(MSBuildProjectName)" Importance="high" />
    <Message Text="Configuration: $(Configuration)" Importance="high" />
    <Message Text="Target Framework: $(TargetFramework)" Importance="high" />
    <Message Text="Git Branch: $(GitBranch)" Importance="high" />
    <Message Text="Git Commit: $(GitCommitIdShort)" Importance="high" />
    <Message Text="Build Number: $(BuildNumber)" Importance="high" />
    <Message Text="Build Date: $(BuildDate)" Importance="high" />
    <Message Text="==========================================================" Importance="high" />
  </Target>

  <!-- Set build date -->
  <PropertyGroup>
    <BuildDate>$([System.DateTime]::UtcNow.ToString('yyyy-MM-ddTHH:mm:ss.fffZ'))</BuildDate>
  </PropertyGroup>

  <!-- Enhanced Project Reference Validation -->
  <Target Name="ValidateProjectReferences" BeforeTargets="BeforeBuild">
    <ItemGroup>
      <InvalidReferences Include="@(ProjectReference)" 
                         Condition="!Exists('%(ProjectReference.Identity)')" />
    </ItemGroup>
    
    <Error Text="Invalid project reference: %(InvalidReferences.Identity)" 
           Condition="'@(InvalidReferences)' != ''" />

    <!-- Validate circular references -->
    <Message Text="Validating project reference graph for $(MSBuildProjectName)" Importance="low" />
  </Target>

  <!-- Source Generator Support -->
  <Target Name="ConfigureSourceGenerators" BeforeTargets="BeforeBuild" Condition="'$(EnableSourceGenerators)' == 'true'">
    <Message Text="Configuring source generators for $(MSBuildProjectName)" Importance="high" />
    
    <ItemGroup>
      <AdditionalFiles Include="**/*.json" Exclude="bin/**;obj/**" />
      <AdditionalFiles Include="**/*.yaml" Exclude="bin/**;obj/**" />
      <AdditionalFiles Include="**/*.yml" Exclude="bin/**;obj/**" />
    </ItemGroup>
  </Target>

  <!-- Dependency Vulnerability Scanning -->
  <Target Name="ScanDependencies" BeforeTargets="Build" Condition="'$(RunDependencyScan)' == 'true'">
    <Message Text="Scanning dependencies for vulnerabilities in $(MSBuildProjectName)" Importance="high" />
    
    <PropertyGroup>
      <DependencyScanOutput>$(MSBuildThisFileDirectory)artifacts\reports\dependency-scan-$(MSBuildProjectName).json</DependencyScanOutput>
    </PropertyGroup>
    
    <Exec Command="dotnet list package --vulnerable --include-transitive --format json --output-file $(DependencyScanOutput)" 
          WorkingDirectory="$(MSBuildProjectDirectory)"
          ContinueOnError="true" />
  </Target>

  <!-- Code quality targets -->
  <Target Name="RunCodeAnalysis" Condition="'$(RunAnalyzersDuringBuild)' == 'true'">
    <Message Text="Running code analysis for $(MSBuildProjectName)" Importance="high" />
    
    <PropertyGroup>
      <CodeAnalysisLogFile>$(MSBuildThisFileDirectory)artifacts\logs\analysis-$(MSBuildProjectName).sarif</CodeAnalysisLogFile>
    </PropertyGroup>
    
    <!-- Enable SARIF output for better tooling integration -->
    <PropertyGroup Condition="'$(Configuration)' == 'Release'">
      <RunAnalyzersDuringBuild>true</RunAnalyzersDuringBuild>
      <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
      <CodeAnalysisRuleSet>$(MSBuildThisFileDirectory)BuildingBlocks.ruleset</CodeAnalysisRuleSet>
    </PropertyGroup>
  </Target>

  <!-- Enhanced Test Coverage -->
  <Target Name="GenerateTestCoverage" AfterTargets="Test" Condition="'$(IsTestProject)' == 'true'">
    <Message Text="Generating test coverage report for $(MSBuildProjectName)" Importance="high" />
    
    <PropertyGroup>
      <CoverageReportPath>$(MSBuildThisFileDirectory)artifacts\coverage\$(MSBuildProjectName)\</CoverageReportPath>
      <CoverageThreshold Condition="'$(CoverageThreshold)' == ''">80</CoverageThreshold>
    </PropertyGroup>
    
    <MakeDir Directories="$(CoverageReportPath)" />
    
    <!-- Generate detailed coverage reports -->
    <Exec Command="dotnet tool restore" WorkingDirectory="$(MSBuildThisFileDirectory)" ContinueOnError="true" />
    <Exec Command="dotnet reportgenerator -reports:$(CoverageReportPath)*.xml -targetdir:$(CoverageReportPath)html -reporttypes:Html;Badges;TextSummary" 
          WorkingDirectory="$(MSBuildThisFileDirectory)" 
          ContinueOnError="true" />
  </Target>

  <!-- Performance Testing -->
  <Target Name="RunPerformanceTests" Condition="'$(IsPerformanceTestProject)' == 'true'">
    <Message Text="Running performance tests for $(MSBuildProjectName)" Importance="high" />
    
    <PropertyGroup>
      <PerfTestResultsPath>$(MSBuildThisFileDirectory)artifacts\performance\$(MSBuildProjectName)\</PerfTestResultsPath>
    </PropertyGroup>
    
    <MakeDir Directories="$(PerfTestResultsPath)" />
    
    <Exec Command="dotnet test --configuration Release --logger:trx --results-directory $(PerfTestResultsPath) -- TestRunParameters.Parameter(name=&quot;ResultsDirectory&quot;, value=&quot;$(PerfTestResultsPath)&quot;)" 
          WorkingDirectory="$(MSBuildProjectDirectory)" />
  </Target>

  <!-- Package validation with enhanced checks -->
  <Target Name="ValidatePackage" AfterTargets="Pack" Condition="'$(IsPackable)' == 'true'">
    <Message Text="Validating package for $(MSBuildProjectName)" Importance="high" />
    
    <ItemGroup>
      <GeneratedPackages Include="$(PackageOutputPath)$(PackageId).*.nupkg" />
    </ItemGroup>
    
    <Message Text="Generated package: %(GeneratedPackages.Identity)" Importance="high" />
    
    <!-- Run package validation -->
    <Exec Command="dotnet tool install --global Microsoft.DotNet.ApiCompat.Tool" ContinueOnError="true" />
    <Exec Command="dotnet package validate %(GeneratedPackages.Identity)" ContinueOnError="true" />
  </Target>

  <!-- Enhanced Documentation Generation -->
  <Target Name="GenerateDocumentation" AfterTargets="Build" Condition="'$(GenerateDocumentationFile)' == 'true' AND '$(Configuration)' == 'Release'">
    <PropertyGroup>
      <DocumentationOutputPath>$(MSBuildThisFileDirectory)artifacts\docs\$(MSBuildProjectName)\</DocumentationOutputPath>
    </PropertyGroup>
    
    <MakeDir Directories="$(DocumentationOutputPath)" />
    
    <Copy SourceFiles="$(OutputPath)$(AssemblyName).xml" 
          DestinationFolder="$(DocumentationOutputPath)" 
          Condition="Exists('$(OutputPath)$(AssemblyName).xml')" />

    <!-- Generate markdown documentation -->
    <Exec Command="dotnet tool restore" WorkingDirectory="$(MSBuildThisFileDirectory)" ContinueOnError="true" />
    <Exec Command="dotnet xmldocmd $(OutputPath)$(AssemblyName).dll --output $(DocumentationOutputPath)" 
          WorkingDirectory="$(MSBuildThisFileDirectory)" 
          ContinueOnError="true" />
  </Target>

  <!-- Security scan with multiple tools -->
  <Target Name="SecurityScan" Condition="'$(RunSecurityScan)' == 'true'">
    <Message Text="Running security scan for $(MSBuildProjectName)" Importance="high" />
    
    <PropertyGroup>
      <SecurityScanOutput>$(MSBuildThisFileDirectory)artifacts\reports\security-$(MSBuildProjectName).json</SecurityScanOutput>
    </PropertyGroup>
    
    <!-- Run DevSkim for security analysis -->
    <Exec Command="dotnet tool install --global Microsoft.CST.DevSkim.CLI" ContinueOnError="true" />
    <Exec Command="devskim analyze $(MSBuildProjectDirectory) --output-file $(SecurityScanOutput) --output-format json" ContinueOnError="true" />
  </Target>

  <!-- Load Testing Integration -->
  <Target Name="RunLoadTests" Condition="'$(IsLoadTestProject)' == 'true'">
    <Message Text="Running load tests for $(MSBuildProjectName)" Importance="high" />
    
    <PropertyGroup>
      <LoadTestResultsPath>$(MSBuildThisFileDirectory)artifacts\load-tests\$(MSBuildProjectName)\</LoadTestResultsPath>
    </PropertyGroup>
    
    <MakeDir Directories="$(LoadTestResultsPath)" />
    
    <!-- Integration with NBomber or k6 -->
    <Exec Command="dotnet run --configuration Release -- --output $(LoadTestResultsPath)" 
          WorkingDirectory="$(MSBuildProjectDirectory)" />
  </Target>

  <!-- Database migration with rollback support -->
  <Target Name="UpdateDatabase" Condition="'$(IsInfrastructureProject)' == 'true' AND '$(RunDatabaseMigrations)' == 'true'">
    <Message Text="Running database migrations for $(MSBuildProjectName)" Importance="high" />
    
    <PropertyGroup>
      <MigrationScriptPath>$(MSBuildThisFileDirectory)artifacts\migrations\$(MSBuildProjectName)\</MigrationScriptPath>
    </PropertyGroup>
    
    <MakeDir Directories="$(MigrationScriptPath)" />
    
    <!-- Generate migration scripts -->
    <Exec Command="dotnet ef migrations script --output $(MigrationScriptPath)migration-$(BuildDate).sql" 
          WorkingDirectory="$(MSBuildProjectDirectory)"
          ContinueOnError="true" />
  </Target>

  <!-- Enhanced API documentation with OpenAPI spec validation -->
  <Target Name="GenerateApiDocumentation" AfterTargets="Build" Condition="'$(IsApiProject)' == 'true' AND '$(Configuration)' == 'Release'">
    <PropertyGroup>
      <ApiDocOutputPath>$(MSBuildThisFileDirectory)artifacts\api-docs\$(MSBuildProjectName)\</ApiDocOutputPath>
      <OpenApiSpecPath>$(ApiDocOutputPath)openapi.json</OpenApiSpecPath>
    </PropertyGroup>
    
    <MakeDir Directories="$(ApiDocOutputPath)" />
    <Message Text="Generating API documentation for $(MSBuildProjectName)" Importance="high" />
    
    <!-- Generate OpenAPI specification -->
    <Exec Command="dotnet tool install --global Microsoft.dotnet-openapi" ContinueOnError="true" />
    <Exec Command="dotnet run --configuration Release --urls http://localhost:0 -- --generate-openapi $(OpenApiSpecPath)" 
          WorkingDirectory="$(MSBuildProjectDirectory)"
          ContinueOnError="true" />
  </Target>

  <!-- Container image build with multi-stage optimization -->
  <Target Name="BuildContainerImage" Condition="'$(BuildContainerImage)' == 'true'">
    <Message Text="Building container image for $(MSBuildProjectName)" Importance="high" />
    
    <PropertyGroup>
      <ContainerImageName>$(MSBuildProjectName.ToLowerInvariant())</ContainerImageName>
      <ContainerImageTag Condition="'$(ContainerImageTag)' == ''">$(Version)</ContainerImageTag>
      <DockerfilePath>$(MSBuildProjectDirectory)\Dockerfile</DockerfilePath>
      <DockerBuildArgs>--build-arg BUILD_VERSION=$(Version) --build-arg BUILD_DATE=$(BuildDate) --build-arg GIT_COMMIT=$(GitCommitIdShort)</DockerBuildArgs>
    </PropertyGroup>
    
    <Error Text="Docker is required to build container images. Please install Docker." 
           Condition="!Exists('$(DockerfilePath)')" />
    
    <!-- Build with performance optimizations -->
    <Exec Command="docker build $(DockerBuildArgs) -t $(ContainerImageName):$(ContainerImageTag) -t $(ContainerImageName):latest -f $(DockerfilePath) ." 
          WorkingDirectory="$(MSBuildProjectDirectory)" 
          ContinueOnError="false"
          Condition="Exists('$(DockerfilePath)')" />

    <!-- Container vulnerability scanning -->
    <Exec Command="docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy:latest image $(ContainerImageName):$(ContainerImageTag)" 
          ContinueOnError="true"
          Condition="'$(RunContainerScan)' == 'true'" />
  </Target>

  <!-- Helm chart packaging with validation -->
  <Target Name="PackageHelmChart" Condition="'$(PackageHelmChart)' == 'true'">
    <Message Text="Packaging Helm chart for $(MSBuildProjectName)" Importance="high" />
    
    <PropertyGroup>
      <HelmChartPath>$(MSBuildThisFileDirectory)charts\$(MSBuildProjectName.ToLowerInvariant())\</HelmChartPath>
      <HelmPackageOutput>$(MSBuildThisFileDirectory)artifacts\helm\</HelmPackageOutput>
      <HelmChartFile>$(HelmChartPath)Chart.yaml</HelmChartFile>
    </PropertyGroup>
    
    <MakeDir Directories="$(HelmPackageOutput)" />
    
    <Error Text="Helm chart not found at $(HelmChartFile)" 
           Condition="!Exists('$(HelmChartFile)')" />
    
    <!-- Validate chart before packaging -->
    <Exec Command="helm lint $(HelmChartPath)" 
          Condition="Exists('$(HelmChartFile)')" 
          ContinueOnError="false" />
    
    <Exec Command="helm package $(HelmChartPath) --destination $(HelmPackageOutput) --version $(Version)" 
          Condition="Exists('$(HelmChartFile)')" 
          ContinueOnError="false" />
  </Target>

  <!-- Enhanced Integration Tests with Environment Management -->
  <Target Name="RunIntegrationTests" Condition="'$(IsIntegrationTestProject)' == 'true'">
    <Message Text="Running integration tests for $(MSBuildProjectName)" Importance="high" />
    
    <PropertyGroup>
      <TestResultsPath>$(MSBuildThisFileDirectory)artifacts\test-results\</TestResultsPath>
      <TestEnvironment Condition="'$(TestEnvironment)' == ''">Development</TestEnvironment>
    </PropertyGroup>
    
    <MakeDir Directories="$(TestResultsPath)" />
    
    <!-- Start test dependencies -->
    <Exec Command="docker-compose -f docker-compose.test.yml up -d" 
          WorkingDirectory="$(MSBuildThisFileDirectory)"
          ContinueOnError="true" 
          Condition="Exists('$(MSBuildThisFileDirectory)docker-compose.test.yml')" />
    
    <!-- Wait for dependencies -->
    <Exec Command="timeout 30" ContinueOnError="true" />
    
    <!-- Run tests with retry -->
    <Exec Command="dotnet test --configuration $(Configuration) --logger trx --results-directory $(TestResultsPath) --environment $(TestEnvironment) --verbosity normal" 
          WorkingDirectory="$(MSBuildProjectDirectory)"
          RetryCount="2"
          RetryDelayInSeconds="5" />
    
    <!-- Cleanup test dependencies -->
    <Exec Command="docker-compose -f docker-compose.test.yml down" 
          WorkingDirectory="$(MSBuildThisFileDirectory)"
          ContinueOnError="true" 
          Condition="Exists('$(MSBuildThisFileDirectory)docker-compose.test.yml')" />
  </Target>

  <!-- Enhanced Benchmark target with result comparison -->
  <Target Name="RunBenchmarks" Condition="'$(IsBenchmarkProject)' == 'true'">
    <Message Text="Running benchmarks for $(MSBuildProjectName)" Importance="high" />
    
    <PropertyGroup>
      <BenchmarkOutputPath>$(MSBuildThisFileDirectory)artifacts\benchmarks\$(MSBuildProjectName)\</BenchmarkOutputPath>
      <BenchmarkBaselinePath>$(MSBuildThisFileDirectory)benchmarks\baseline\</BenchmarkBaselinePath>
    </PropertyGroup>
    
    <MakeDir Directories="$(BenchmarkOutputPath)" />
    
    <Exec Command="dotnet run --configuration Release -- --artifacts $(BenchmarkOutputPath) --exporters json,html --memory --runtimes net8.0" 
          WorkingDirectory="$(MSBuildProjectDirectory)" />
    
    <!-- Compare with baseline if available -->
    <Exec Command="dotnet tool install --global BenchmarkDotNet.Tool" ContinueOnError="true" />
    <Exec Command="dotnet benchmark compare $(BenchmarkBaselinePath) $(BenchmarkOutputPath)" 
          ContinueOnError="true"
          Condition="Exists('$(BenchmarkBaselinePath)')" />
  </Target>

  <!-- Enhanced cleanup with logging -->
  <Target Name="CleanupTempFiles" AfterTargets="Build">
    <ItemGroup>
      <TempFiles Include="$(MSBuildProjectDirectory)\**\*.tmp" />
      <TempFiles Include="$(MSBuildProjectDirectory)\**\*.cache" />
      <TempFiles Include="$(BaseIntermediateOutputPath)**\*.tmp" />
      <TempFiles Include="$(MSBuildProjectDirectory)\**\node_modules\**" Condition="'$(CleanNodeModules)' == 'true'" />
    </ItemGroup>
    
    <Delete Files="@(TempFiles)" ContinueOnError="true" />
    <Message Text="Cleaned up temporary files" Importance="low" />
  </Target>

  <!-- Build Summary Report -->
  <Target Name="GenerateBuildSummary" AfterTargets="Build" Condition="'$(GenerateBuildSummary)' == 'true'">
    <PropertyGroup>
      <BuildSummaryPath>$(MSBuildThisFileDirectory)artifacts\reports\build-summary-$(MSBuildProjectName).json</BuildSummaryPath>
      <BuildSummaryContent>
{
  "project": "$(MSBuildProjectName)",
  "configuration": "$(Configuration)",
  "targetFramework": "$(TargetFramework)",
  "buildDate": "$(BuildDate)",
  "gitCommit": "$(GitCommitId)",
  "gitBranch": "$(GitBranch)",
  "buildNumber": "$(BuildNumber)",
  "version": "$(Version)",
  "succeeded": true
}
      </BuildSummaryContent>
    </PropertyGroup>
    
    <WriteLinesToFile File="$(BuildSummaryPath)" Lines="$(BuildSummaryContent)" Overwrite="true" />
  </Target>

  <!-- Enhanced project type detection -->
  <PropertyGroup>
    <IsApiProject Condition="$(MSBuildProjectName.Contains('API')) OR $(MSBuildProjectFile.Contains('\API\')) OR $(MSBuildProjectName.Contains('WebApi'))">true</IsApiProject>
    <IsInfrastructureProject Condition="$(MSBuildProjectName.Contains('Infrastructure')) OR $(MSBuildProjectFile.Contains('\Infrastructure\'))">true</IsInfrastructureProject>
    <IsDomainProject Condition="$(MSBuildProjectName.Contains('Domain')) OR $(MSBuildProjectFile.Contains('\Domain\'))">true</IsDomainProject>
    <IsApplicationProject Condition="$(MSBuildProjectName.Contains('Application')) OR $(MSBuildProjectFile.Contains('\Application\'))">true</IsApplicationProject>
    <IsIntegrationTestProject Condition="$(MSBuildProjectName.Contains('IntegrationTests')) OR $(MSBuildProjectName.Contains('Integration.Tests'))">true</IsIntegrationTestProject>
    <IsBenchmarkProject Condition="$(MSBuildProjectName.Contains('Benchmarks')) OR $(MSBuildProjectName.Contains('Benchmark'))">true</IsBenchmarkProject>
    <IsPerformanceTestProject Condition="$(MSBuildProjectName.Contains('PerformanceTests')) OR $(MSBuildProjectName.Contains('Performance.Tests'))">true</IsPerformanceTestProject>
    <IsLoadTestProject Condition="$(MSBuildProjectName.Contains('LoadTests')) OR $(MSBuildProjectName.Contains('Load.Tests'))">true</IsLoadTestProject>
  </PropertyGroup>

  <!-- Add Global Package References -->
  <Target Name="AddGlobalPackageReferences" BeforeTargets="CollectPackageReferences">
    
    <!-- Source Link for all projects except tests and benchmarks -->
    <ItemGroup Condition="'$(IsSourceLinkSupported)' != 'false' AND '$(IsTestProject)' != 'true' AND '$(IsBenchmarkProject)' != 'true'">
      <PackageReference Include="Microsoft.SourceLink.GitHub" PrivateAssets="All" />
    </ItemGroup>

    <!-- MinVer for versioning (all packable projects) -->
    <ItemGroup Condition="'$(UseMinVer)' != 'false' AND '$(IsPackable)' == 'true'">
      <PackageReference Include="MinVer" PrivateAssets="All" />
    </ItemGroup>

    <!-- Core Microsoft Extensions (all projects) -->
    <ItemGroup>
      <PackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" />
      <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" />
      <PackageReference Include="Microsoft.Extensions.Configuration.Abstractions" />
      <PackageReference Include="System.ComponentModel.Annotations" />
    </ItemGroup>

    <!-- Nullable reference types analyzer -->
    <ItemGroup Condition="'$(Nullable)' == 'enable'">
      <PackageReference Include="Nullable" PrivateAssets="All" />
    </ItemGroup>

  </Target>

  <!-- BuildingBlocks-specific Package References -->
  <Target Name="AddBuildingBlocksPackageReferences" BeforeTargets="CollectPackageReferences">

    <!-- BuildingBlocks Domain layer specific packages -->
    <ItemGroup Condition="'$(MSBuildProjectName)' == 'BuildingBlocks.Domain'">
      <PackageReference Include="System.Text.Json" />
    </ItemGroup>

    <!-- BuildingBlocks Application layer specific packages -->
    <ItemGroup Condition="'$(MSBuildProjectName)' == 'BuildingBlocks.Application'">
      <PackageReference Include="Microsoft.Extensions.Caching.Memory" />
      <PackageReference Include="Microsoft.Extensions.Caching.StackExchangeRedis" />
      <PackageReference Include="Microsoft.Extensions.Hosting.Abstractions" />
      <PackageReference Include="Scrutor" />
    </ItemGroup>

    <!-- BuildingBlocks Infrastructure layer specific packages -->
    <ItemGroup Condition="'$(MSBuildProjectName)' == 'BuildingBlocks.Infrastructure'">
      <PackageReference Include="Microsoft.EntityFrameworkCore" />
      <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" />
      <PackageReference Include="Microsoft.EntityFrameworkCore.InMemory" />
      <PackageReference Include="Microsoft.Extensions.Caching.Memory" />
      <PackageReference Include="Microsoft.Extensions.Caching.StackExchangeRedis" />
      <PackageReference Include="StackExchange.Redis" />
      <PackageReference Include="System.IdentityModel.Tokens.Jwt" />
      <PackageReference Include="FluentValidation" />
      <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks" />
    </ItemGroup>

    <!-- BuildingBlocks API layer specific packages -->
    <ItemGroup Condition="'$(MSBuildProjectName)' == 'BuildingBlocks.API'">
      <PackageReference Include="FluentValidation" />
      <PackageReference Include="FluentValidation.DependencyInjectionExtensions" />
      <PackageReference Include="Microsoft.AspNetCore.OpenApi" />
      <PackageReference Include="Scalar.AspNetCore" />
      <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" />
      <PackageReference Include="Asp.Versioning.Http" />
      <PackageReference Include="Asp.Versioning.Mvc.ApiExplorer" />
      <PackageReference Include="Serilog.AspNetCore" />
      <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks" />
      <PackageReference Include="Microsoft.AspNetCore.ResponseCompression" />
      <PackageReference Include="Microsoft.Extensions.Caching.Memory" />
      <PackageReference Include="Microsoft.AspNetCore.Mvc.Core" />
      <PackageReference Include="Microsoft.AspNetCore.Authorization" />
    </ItemGroup>

  </Target>

  <!-- Add Domain Project Package References -->
  <Target Name="AddDomainPackageReferences" BeforeTargets="CollectPackageReferences" Condition="'$(IsDomainProject)' == 'true' AND '$(MSBuildProjectName)' != 'BuildingBlocks.Domain'">
    <!-- Domain projects typically only need minimal dependencies -->
    
    <!-- Domain modeling helpers -->
    <ItemGroup Condition="'$(IncludeDomainHelpers)' != 'false'">
      <PackageReference Include="Ardalis.GuardClauses" />
      <PackageReference Include="CSharpFunctionalExtensions" />
    </ItemGroup>
  </Target>

  <!-- Add Application Project Package References -->
  <Target Name="AddApplicationPackageReferences" BeforeTargets="CollectPackageReferences" Condition="'$(IsApplicationProject)' == 'true' AND '$(MSBuildProjectName)' != 'BuildingBlocks.Application'">
    
    <ItemGroup>
      <PackageReference Include="Microsoft.Extensions.Hosting.Abstractions" />
      <PackageReference Include="Microsoft.Extensions.Caching.Abstractions" />
    </ItemGroup>

    <!-- FluentValidation for application layer -->
    <ItemGroup Condition="'$(IncludeValidation)' != 'false'">
      <PackageReference Include="FluentValidation" />
      <PackageReference Include="FluentValidation.DependencyInjectionExtensions" />
    </ItemGroup>

    <!-- MediatR for CQRS -->
    <ItemGroup Condition="'$(IncludeMediatR)' == 'true'">
      <PackageReference Include="MediatR" />
      <PackageReference Include="MediatR.Extensions.Microsoft.DependencyInjection" />
    </ItemGroup>

  </Target>

  <!-- Add Infrastructure Project Package References -->
  <Target Name="AddInfrastructurePackageReferences" BeforeTargets="CollectPackageReferences" Condition="'$(IsInfrastructureProject)' == 'true' AND '$(MSBuildProjectName)' != 'BuildingBlocks.Infrastructure'">
    
    <!-- Core infrastructure dependencies -->
    <ItemGroup>
      <PackageReference Include="Microsoft.Extensions.Options" />
      <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" />
      <PackageReference Include="Microsoft.Extensions.Http" />
    </ItemGroup>

    <!-- Entity Framework Core -->
    <ItemGroup Condition="'$(IncludeEntityFramework)' != 'false'">
      <PackageReference Include="Microsoft.EntityFrameworkCore" />
      <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" />
      <PackageReference Include="Microsoft.EntityFrameworkCore.InMemory" />
      <PackageReference Include="Microsoft.EntityFrameworkCore.Design" PrivateAssets="All" />
      <PackageReference Include="Microsoft.EntityFrameworkCore.Tools" PrivateAssets="All" />
    </ItemGroup>

    <!-- Caching -->
    <ItemGroup Condition="'$(IncludeCaching)' != 'false'">
      <PackageReference Include="Microsoft.Extensions.Caching.Memory" />
      <PackageReference Include="Microsoft.Extensions.Caching.StackExchangeRedis" />
      <PackageReference Include="StackExchange.Redis" />
    </ItemGroup>

    <!-- Authentication & Authorization -->
    <ItemGroup Condition="'$(IncludeAuthentication)' != 'false'">
      <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" />
      <PackageReference Include="Microsoft.AspNetCore.Authorization" />
      <PackageReference Include="System.IdentityModel.Tokens.Jwt" />
      <PackageReference Include="BCrypt.Net-Next" />
    </ItemGroup>

    <!-- Mapping -->
    <ItemGroup Condition="'$(IncludeMapping)' != 'false'">
      <PackageReference Include="AutoMapper" />
      <PackageReference Include="AutoMapper.Extensions.Microsoft.DependencyInjection" />
      <PackageReference Include="Mapster" />
      <PackageReference Include="Mapster.DependencyInjection" />
    </ItemGroup>

    <!-- Validation -->
    <ItemGroup Condition="'$(IncludeValidation)' != 'false'">
      <PackageReference Include="FluentValidation" />
      <PackageReference Include="FluentValidation.DependencyInjectionExtensions" />
    </ItemGroup>

    <!-- Serialization -->
    <ItemGroup Condition="'$(IncludeSerialization)' != 'false'">
      <PackageReference Include="System.Text.Json" />
      <PackageReference Include="Newtonsoft.Json" />
      <PackageReference Include="Google.Protobuf" />
      <PackageReference Include="MessagePack" />
      <PackageReference Include="CsvHelper" />
    </ItemGroup>

    <!-- Background Services -->
    <ItemGroup Condition="'$(IncludeBackgroundServices)' != 'false'">
      <PackageReference Include="Hangfire" />
      <PackageReference Include="Hangfire.SqlServer" />
      <PackageReference Include="Hangfire.MemoryStorage" />
    </ItemGroup>

    <!-- Messaging -->
    <ItemGroup Condition="'$(IncludeMessaging)' != 'false'">
      <PackageReference Include="Azure.Messaging.ServiceBus" />
      <PackageReference Include="RabbitMQ.Client" />
      <PackageReference Include="MassTransit" />
      <PackageReference Include="MassTransit.RabbitMQ" />
    </ItemGroup>

    <!-- Monitoring & Observability -->
    <ItemGroup Condition="'$(IncludeMonitoring)' != 'false'">
      <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks" />
      <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore" />
      <PackageReference Include="OpenTelemetry" />
      <PackageReference Include="OpenTelemetry.Extensions.Hosting" />
      <PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" />
      <PackageReference Include="OpenTelemetry.Instrumentation.EntityFrameworkCore" />
      <PackageReference Include="Serilog" />
      <PackageReference Include="Serilog.Extensions.Hosting" />
    </ItemGroup>

    <!-- Security -->
    <ItemGroup Condition="'$(IncludeSecurity)' != 'false'">
      <PackageReference Include="System.Security.Cryptography.Algorithms" />
    </ItemGroup>

    <!-- Storage -->
    <ItemGroup Condition="'$(IncludeCloudStorage)' != 'false'">
      <PackageReference Include="Azure.Storage.Blobs" />
      <PackageReference Include="AWSSDK.S3" />
    </ItemGroup>

    <!-- Communication -->
    <ItemGroup Condition="'$(IncludeEmailServices)' != 'false'">
      <PackageReference Include="MailKit" />
      <PackageReference Include="MimeKit" />
    </ItemGroup>

    <!-- HTTP -->
    <ItemGroup Condition="'$(IncludeHttpClient)' != 'false'">
      <PackageReference Include="Polly" />
      <PackageReference Include="Polly.Extensions.Http" />
    </ItemGroup>

    <!-- Utilities -->
    <ItemGroup>
      <PackageReference Include="Microsoft.Extensions.FileProviders.Abstractions" />
    </ItemGroup>

  </Target>

  <!-- Add API Project Package References -->
  <Target Name="AddApiPackageReferences" BeforeTargets="CollectPackageReferences" Condition="'$(IsApiProject)' == 'true' AND '$(MSBuildProjectName)' != 'BuildingBlocks.API'">
    
    <!-- Core ASP.NET Core -->
    <ItemGroup>
      <PackageReference Include="Microsoft.AspNetCore.OpenApi" />
      <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" />
      <PackageReference Include="Microsoft.AspNetCore.Authorization" />
      <PackageReference Include="Microsoft.AspNetCore.Cors" />
      <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" />
    </ItemGroup>

    <!-- API Versioning -->
    <ItemGroup Condition="'$(IncludeApiVersioning)' != 'false'">
      <PackageReference Include="Asp.Versioning.Http" />
      <PackageReference Include="Asp.Versioning.Mvc.ApiExplorer" />
    </ItemGroup>

    <!-- OpenAPI/Swagger -->
    <ItemGroup Condition="'$(IncludeSwagger)' != 'false'">
      <PackageReference Include="Swashbuckle.AspNetCore" />
      <PackageReference Include="Swashbuckle.AspNetCore.Annotations" />
      <PackageReference Include="Swashbuckle.AspNetCore.Filters" />
      <PackageReference Include="Scalar.AspNetCore" />
    </ItemGroup>

    <!-- Validation -->
    <ItemGroup Condition="'$(IncludeValidation)' != 'false'">
      <PackageReference Include="FluentValidation.AspNetCore" />
      <PackageReference Include="FluentValidation.DependencyInjectionExtensions" />
    </ItemGroup>

    <!-- Rate Limiting -->
    <ItemGroup Condition="'$(IncludeRateLimiting)' != 'false'">
      <PackageReference Include="Microsoft.AspNetCore.RateLimiting" />
      <PackageReference Include="AspNetCoreRateLimit" />
    </ItemGroup>

    <!-- Health Checks -->
    <ItemGroup Condition="'$(IncludeHealthChecks)' != 'false'">
      <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks" />
      <PackageReference Include="Microsoft.AspNetCore.Diagnostics.HealthChecks" />
      <PackageReference Include="AspNetCore.HealthChecks.UI" />
      <PackageReference Include="AspNetCore.HealthChecks.UI.InMemory.Storage" />
    </ItemGroup>

    <!-- Monitoring & Observability -->
    <ItemGroup Condition="'$(IncludeMonitoring)' != 'false'">
      <PackageReference Include="OpenTelemetry.AspNetCore" />
      <PackageReference Include="OpenTelemetry.Extensions.Hosting" />
      <PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" />
    </ItemGroup>

    <!-- Security -->
    <ItemGroup Condition="'$(IncludeSecurity)' != 'false'">
      <PackageReference Include="Microsoft.AspNetCore.DataProtection" />
      <PackageReference Include="Microsoft.AspNetCore.HttpsPolicy" />
    </ItemGroup>

    <!-- Serialization -->
    <ItemGroup Condition="'$(IncludeSerialization)' != 'false'">
      <PackageReference Include="System.Text.Json" />
      <PackageReference Include="Newtonsoft.Json" />
      <PackageReference Include="Microsoft.AspNetCore.Mvc.NewtonsoftJson" />
    </ItemGroup>

    <!-- HTTP Client -->
    <ItemGroup Condition="'$(IncludeHttpClient)' != 'false'">
      <PackageReference Include="Microsoft.Extensions.Http" />
      <PackageReference Include="Polly.Extensions.Http" />
    </ItemGroup>

  </Target>

  <!-- Add Test-specific Package References -->
  <Target Name="AddTestPackageReferences" BeforeTargets="CollectPackageReferences" Condition="'$(IsTestProject)' == 'true'">
    
    <ItemGroup>
      <PackageReference Include="coverlet.collector" PrivateAssets="All" />
      <PackageReference Include="coverlet.msbuild" PrivateAssets="All" />
    </ItemGroup>

    <!-- Add common test packages -->
    <ItemGroup Condition="'$(IncludeTestFramework)' != 'false'">
      <PackageReference Include="Microsoft.NET.Test.Sdk" PrivateAssets="All" />
      <PackageReference Include="xunit" PrivateAssets="All" />
      <PackageReference Include="xunit.runner.visualstudio" PrivateAssets="All" />
      <PackageReference Include="FluentAssertions" PrivateAssets="All" />
      <PackageReference Include="Bogus" PrivateAssets="All" />
    </ItemGroup>

    <!-- Integration test specific packages -->
    <ItemGroup Condition="'$(IsIntegrationTestProject)' == 'true'">
      <PackageReference Include="Microsoft.AspNetCore.Mvc.Testing" PrivateAssets="All" />
      <PackageReference Include="Testcontainers" PrivateAssets="All" />
      <PackageReference Include="Microsoft.EntityFrameworkCore.InMemory" PrivateAssets="All" />
    </ItemGroup>

  </Target>

  <!-- Add Benchmark-specific Package References -->
  <Target Name="AddBenchmarkPackageReferences" BeforeTargets="CollectPackageReferences" Condition="'$(IsBenchmarkProject)' == 'true'">
    
    <ItemGroup>
      <PackageReference Include="BenchmarkDotNet" />
      <PackageReference Include="BenchmarkDotNet.Diagnostics.Windows" Condition="$([MSBuild]::IsOSPlatform('Windows'))" />
    </ItemGroup>

  </Target>

  <!-- Add Performance Test Package References -->
  <Target Name="AddPerformanceTestPackageReferences" BeforeTargets="CollectPackageReferences" Condition="'$(IsPerformanceTestProject)' == 'true'">
    
    <ItemGroup>
      <PackageReference Include="NBomber" />
      <PackageReference Include="Microsoft.Extensions.Http" />
    </ItemGroup>

  </Target>

</Project> 